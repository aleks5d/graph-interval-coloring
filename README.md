# graph-interval-coloring

# условие

Дан граф G(V, E) и длительность каждой вершины. Необходимо каждой вершине сопоставить непрерывный полуинтервал [l, r) такой, чтобы r - l = W[i], для соседних вершин эти полуинтервалы не пересекаются и максимальное r минимально. 

## немного общей теории

V - множество вершин

Е - множество ребер

W - множество весов вершин

G(V, E) - граф на множестве вершин V с множеством ребер E

F(V, E) - оптимальный ответ для графа G(V, E)

E(A) - ребра из множества E такие, что хотя-бы один их конец лежит в A

E(A, A) - ребра из множества E такие, что оба их конца лежат в A

Тогда можно заметить некоторые факты:

1. F(\empty, \empty) = 0

2. F(V, \empty) = max (v in V) W[v]

3. A - subet of V --> F(V / A, E / E(A)) <= F(V, E) <= F(V / A, E / E(A)) + F(A, E(A, A))

4. A - independent subset of V --> F(V / A, E / E(A)) <= F(V, E) <= F(V / A, E / E(A)) + max (v in A) W[v]

5. A[1..k] - independent subset of V,  sum A[i] = V --> 
    
    max F(A[i], \empty) <= F(V, E) <= sum F(A[i], \empty) <= k * max F(A[i], \empty)
    
6. H(V, E) - хроматическое число G(V, E) --> F(V, E) <= H(V, E) * max W[i]


## greedy-coloring-1

Алгоритм каждый раз жадно набирает независимое множество и запускает все вершины в один момент. Время работы такого множества = максимумальное время работы элементов множества

Решение неточное, работает за O(n * m)

## greedy-coloring-2

Изначально вершины сортируются по времени работы. Далее запускается greedy-coloring-1

Решение неточное, работает за O(n * m)

## spanning-tree-1

В исходный граф добавляется новая вершина с номером 0 и длительностью 0. Из нее проводятся ребра во все вершины. Теперь перебираются все остовные деревья этого графа, подвешиваются за 0 и l[v] = r[pre[v]] - время начала исполнения вершины пологается равным времени окончания исполнения ее предка.

Давайте докажем корректность этого алгоритма:

Для начала заметим, что для любой верины ее время начала либо 0, либо время окончания одного из его соседей. Допустим, это не так. Тогда нет ни одного соседа, что исполняется в момент времени l-1, а значит ничего не мешает нам началь исполнять эту вершину раньше.

Теперь пусть вершина v начинает исполняться за u, тогда оставим ребро u-v. Таким образом, исходный граф разбился на лес. Для того, чтобы это продолжал быть остов и создается новая вершина, не влияющая на общее время исполнения.

Значит теперь оптимальный ответ можно закодировать (возможно не одним) остовным деревом. Значит, перебрав все деревья, мы когда-то посмотрим и на правильный ответ.

Решение работает за O(2^(m + n) * (n + m)), так как перебираются все подмножества ребер

## spanning-tree-2

Решение, аналогичное предыдущему, но теперь ведется перебор лишь множеств подмножеств размера n из множества размера (n + m). 

Решение работает за O(C_{m+n}^n) (я пока не смог нормльно это вывести)

## permutation-1

Заметим, что по аналогии со spanning-tree-1, мы можем кодировать все как перестановку. Для того чтобы раскодировать перестановку, давайте вершине назначать время начала равное максимуму времен окончания вершин соединенных с ней и находящихся в перестановке раньше. Чтобы закодировать в перестановку, просто сортируем вершины по времени начала. 

Решение точное, за O(n! * (n + m))

## permutation-2 

Можно заметить, что если не перебирать перестановку и по ней восстанавливать ответ, а делать это параллельно, то можно сразу отсекать плохие перестановки. Так как кодирование происходит сортировкой по времени начала, то если  процессе раскодировки start[perm[i]] > start[perm[i - 1]], то можно сраз прекратить обработку таких перестновок

Решение точное, за O(n! * (n + m)) 
