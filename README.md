# graph-interval-coloring

# условие

Дан граф G(V, E) и длительность каждой вершины. Необходимо каждой вершине сопоставить непрерывный полуинтервал [l, r) такой, чтобы r - l = len[i], и максимальное r минимально. 

## greedy-coloring-1

Алгоритм каждый раз жадно набирает независимое множество и запускает все вершины в один момент. Время работы такого множества = максимумальное время работы элементов множества

Решение неточное, работает за O(n * m)

## greedy-coloring-2

Изначально вершины сортируются по времени работы. Далее запускается greedy-coloring-1

Решение неточное, работает за O(n * m)

## spanning-tree-1

В исходный граф добавляется новая вершина с номером 0 и длительностью 0. Из нее проводятся ребра во все вершины. Теперь перебираются все остовные деревья этого графа, подвешиваются за 0 и l[v] = r[pre[v]] - время начала исполнения вершины пологается равным времени окончания исполнения ее предка.

Давайте докажем корректность этого алгоритма:

Для начала заметим, что для любой верины ее время начала либо 0, либо время окончания одного из его соседей. Допустим, это не так. Тогда нет ни одного соседа, что исполняется в момент времени l-1, а значит ничего не мешает нам началь исполнять эту вершину раньше.

Теперь пусть вершина v начинает исполняться за u, тогда оставим ребро u-v. Таким образом, исходный граф разбился на лес. Для того, чтобы это продолжал быть остов и создается новая вершина, не влияющая на общее время исполнения.

Значит теперь оптимальный ответ можно закодировать (возможно не одним) остовным деревом. Значит, перебрав все деревья, мы когда-то посмотрим и на правильный ответ.

Решение работает за O(2^(m + n) * (n + m)), так как перебираются все подмножества ребер

## spanning-tree-2

Решение, аналогичное предыдущему, но теперь ведется перебор лишь множеств подмножеств размера n из множества размера (n + m). 

Решение работает за O(C_{m+n}^n) (я пока не смог нормльно это вывести)

## permutation-1

Заметим, что по аналогии со spanning-tree-1, мы можем кодировать все как перестановку. Для того чтобы раскодировать перестановку, давайте вершине назначать время начала равное максимуму времен окончания вершин соединенных с ней и находящихся в перестановке раньше. Чтобы закодировать в перестановку, просто сортируем вершины по времени начала. 

Решение точное, за O(n! * (n + m) )

## permutation-2 

Можно заметить, что если не перебирать перестановку и по ней восстанавливать ответ, а делать это параллельно, то можно сразу отсекать плохие перестановки. Так как кодирование происходит сортировкой по времени начала, то если  процессе раскодировки start[perm[i]] > start[perm[i - 1]], то можно сраз прекратить обработку таких перестновок

Решение точное, за O(n! * (n + m)) 
